<!DOCTYPE html>
<html>
<head>
<title>2021.11.16-2021.11.20</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="1116">11.16</h1>
<h2 id="svlab4">SVLAB4</h2>
<h3 id="%E5%AE%9E%E9%AA%8C4%E9%AA%8C%E8%AF%81%E7%8E%AF%E5%A2%83">实验4验证环境</h3>
<div align="center"><img src="svlab4.drawio.png"></img></div>
<h3 id="%E5%92%8C--%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB"><code>::</code> 和 <code>.</code> 索引的区别</h3>
<ul>
<li>双冒号是从某个域中索引（package，class）</li>
<li><code>.</code> 是从某个实例中找到它的某个属性（变量，方法，信号等等）</li>
</ul>
<h3 id="%E8%A7%A3%E5%86%B3%E6%98%A8%E5%A4%A9%E9%97%AE%E9%A2%98">解决昨天问题</h3>
<ul>
<li>interface中的clocking不会自带时钟周期</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">class</span> driver;

  <span class="hljs-keyword">virtual</span> chnl_intf intf;

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>(<span class="hljs-keyword">virtual</span> chnl_intf intf);
    <span class="hljs-keyword">this</span><span class="hljs-variable">.intf</span> = intf;
  <span class="hljs-keyword">endfunction</span>
  
  <span class="hljs-keyword">task</span> drive();
    <span class="hljs-comment">// @(posedge intf.clk);</span>
    intf<span class="hljs-variable">.drv_ck</span><span class="hljs-variable">.a</span> &lt;= <span class="hljs-number">1</span>;
  <span class="hljs-keyword">endtask</span>

<span class="hljs-keyword">endclass</span>

<span class="hljs-keyword">interface</span> chnl_intf(<span class="hljs-keyword">input</span> clk, <span class="hljs-keyword">input</span> rstn);
  <span class="hljs-keyword">logic</span> a;

  <span class="hljs-keyword">clocking</span> drv_ck @(<span class="hljs-keyword">posedge</span> clk);
    <span class="hljs-keyword">default</span> <span class="hljs-keyword">input</span> #<span class="hljs-number">1</span>ns <span class="hljs-keyword">output</span> #<span class="hljs-number">1</span>ns;
    <span class="hljs-keyword">output</span> a;
  <span class="hljs-keyword">endclocking</span>

<span class="hljs-keyword">endinterface</span>

<span class="hljs-keyword">module</span> test;
  
  <span class="hljs-keyword">logic</span> clk, rstn;
  
  chnl_intf intf(.*);
  
  driver drv = <span class="hljs-keyword">new</span>(intf);
  <span class="hljs-keyword">always</span> #<span class="hljs-number">10</span>ns clk = !clk;

  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span>
    clk = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">repeat</span>(<span class="hljs-number">5</span>) @(<span class="hljs-keyword">posedge</span> clk);
    drv<span class="hljs-variable">.drive</span>();
    #<span class="hljs-number">3</span>ns;
    <span class="hljs-built_in">$finish</span>;
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">endmodule</span>
</div></code></pre>
<p>上述代码中会在第五个周期给a驱动，如果在drive()中加一个 <code>@(posedge intf.clk)</code> ，则会在第六个周期给a驱动，这句代码后有没有分号没有影响</p>
<h1 id="1117">11.17</h1>
<h2 id="sv%E9%AA%8C%E8%AF%81%E7%B2%BE%E9%80%9A6">SV验证精通6</h2>
<h3 id="%E8%A6%86%E7%9B%96%E7%8E%87%E7%B1%BB%E5%9E%8B">覆盖率类型</h3>
<ul>
<li>代码覆盖率
<ul>
<li>包括行覆盖率，路径覆盖率，翻转覆盖率，分支覆盖率，状态机覆盖率。</li>
<li>关注点在设计代码的分析上，而不是测试平台</li>
<li>未经测试的设计代码里可能隐藏硬件漏洞，也可能仅仅就是冗余的代码。</li>
<li>代码覆盖率100%不意味着验证工作已经完成，但是必要条件</li>
</ul>
</li>
<li>断言覆盖率
<ul>
<li>断言是用于一次性或在一段时间对一个或者多个设计信号在逻辑或者时序上的声明性代码</li>
<li>断言最常用于查找错误，例如两个信号是否应该互斥，或者请求与许可信号之间的时序等</li>
<li>可以使用 <code>cover property</code> 来测量这些关心的信号值或者状态是否发生</li>
</ul>
</li>
<li>漏洞率曲线
<ul>
<li>应该寻找各种不同的办法去测试可能的边界情况（corner case）</li>
</ul>
</li>
<li>功能覆盖率
<ul>
<li>功能覆盖率是和功能设计意图紧密相连的，有时也被称为描述覆盖率，代码覆盖率是衡量设计的实际情况</li>
<li>某个功能在设计中可以被遗漏，代码覆盖率不能发现这个错误，但是功能覆盖率可以</li>
</ul>
</li>
</ul>
<div align="center"><img src="1.png"></img></div>
<h1 id="1118">11.18</h1>
<h2 id="sv%E9%AA%8C%E8%AF%81%E7%B2%BE%E9%80%9A6">SV验证精通6</h2>
<h3 id="%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87">代码覆盖率</h3>
<ul>
<li>代码覆盖的目的是确定是否忘记在设计中执行某些代码</li>
<li>代码覆盖率100%并不意味着足够的功能覆盖率</li>
<li>对于行覆盖率：有必要了解导致执行未覆盖语句所需的条件（if else）</li>
<li>分支覆盖率：用来对条件语句，指出其执行的分支轨迹</li>
<li>条件覆盖率：衡量一些布尔表达式中各个条件真伪判断的执行轨迹</li>
<li>状态机覆盖率：每个状态的进入次数，状态之间的跳转次数，以及多个状态的跳转顺序</li>
<li>跳转覆盖率：衡量寄存器跳转的次数，端口跳转覆盖率经常用来测试IP模块之间的基本连接性。</li>
</ul>
<h3 id="%E5%8A%9F%E8%83%BD%E8%A6%86%E7%9B%96%E7%AD%96%E7%95%A5">功能覆盖策略</h3>
<ul>
<li>只测量需要的内容</li>
<li>如果代码覆盖率低但功能覆盖率高，说明验证计划不完整，测试没有执行设计的所有代码</li>
<li>如果代码覆盖率高但功能覆盖率低，说明测试平台很好地执行了设计的所有代码，但是测试还是没有把设计定位到所有感兴趣的状态上</li>
</ul>
<h3 id="%E8%A6%86%E7%9B%96%E7%BB%84">覆盖组</h3>
<ul>
<li>概述
<ul>
<li>covergroup与类相似，一次定义后便可以多次实例化</li>
<li>covergroup可以包含一个或者多个coverpoint，且全都在同一时间采集</li>
<li>covergroup可以定义在类中，也可以定义在interface或者module中</li>
<li>covergroup可以采样任何可见的变量，例如程序变量，接口信号或者设计端口</li>
<li>类里可以包含多个covergroup，每个covergroup可以根据需要自行使能或者禁止</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">class</span> Transactor;
  Transaction tr;
  
  <span class="hljs-keyword">covergroup</span> CovPort;
    <span class="hljs-keyword">coverpoint</span> tr<span class="hljs-variable">.port</span>;
  <span class="hljs-keyword">endgroup</span>

  <span class="hljs-keyword">function</span> <span class="hljs-keyword">new</span>();
    CovPort = <span class="hljs-keyword">new</span>(); <span class="hljs-comment">// 例化对象的名字和类型的名字一样，也可以写 CovPort cg1 = new();</span>
  <span class="hljs-keyword">endfunction</span>

  <span class="hljs-keyword">task</span> main;
    <span class="hljs-keyword">forever</span> <span class="hljs-keyword">begin</span>
      CovPort<span class="hljs-variable">.sample</span>(); <span class="hljs-comment">// 可以在定义covergroup的时候用 @(...) 来规定什么时候采样</span>
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">endtask</span>
<span class="hljs-keyword">endclass</span>
</div></code></pre>
<ul>
<li>covergroup采样触发
<ul>
<li>可以用sample或者@来触发采样</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">event</span> trans_ready;
<span class="hljs-keyword">covergroup</span> CovPort @(trans_ready);
  <span class="hljs-keyword">coverpoint</span> ifc<span class="hljs-variable">.cb</span><span class="hljs-variable">.port</span>;
<span class="hljs-keyword">endgroup</span>
</div></code></pre>
<h1 id="1119">11.19</h1>
<h2 id="%E6%95%B0%E6%8D%AE%E9%87%87%E6%A0%B7">数据采样</h2>
<ul>
<li>概述
<ul>
<li>在coverpoint指定采样一个变量或者表达式时，SV会创建很多的bin来记录每个数值被捕捉到的次数，这些bin是衡量功能覆盖率的基本单位</li>
<li>covergroup中可以定义多个coverpoint，coverpoint中可以自定义多个cover bin或者SV帮助自动定义多个cover bin</li>
<li>每次covergroup采样，SV都会在一个或者多个cover bin中留下标记，用来记录采样时变量的数值和匹配的cover bin</li>
</ul>
</li>
<li>coverpoint和bin
<ul>
<li>为了计算一个coverpoint上的覆盖率，首先需要确定可能数值的个数，也被称为域</li>
<li>覆盖率就是采样值的数目除以bin的数目</li>
<li>所有coverpoint的覆盖率最终构成一个covergroup的覆盖率，所有covergroup的覆盖率构成了整体的功能覆盖率</li>
</ul>
</li>
<li>bin的创建和应用
<ul>
<li>用户自定义bin的采样域，若没有指定bin且域的范围过大，系统会默认分配64个bin</li>
<li>可以通过 <code>auto_bin_max</code> 来指定自动创建bin的最大数目</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">covergroup</span> CovPort;
  options<span class="hljs-variable">.auto_bin_max</span> = <span class="hljs-number">8</span>; <span class="hljs-comment">//所有coverpoint auto_bin数量为8</span>
  <span class="hljs-keyword">coverpoint</span> tr<span class="hljs-variable">.port</span>
    { options<span class="hljs-variable">.auto_bin_max</span> = <span class="hljs-number">2</span>;} <span class="hljs-comment">//特定coverpoint auto_bin数量为2</span>
<span class="hljs-keyword">endgroup</span>
</div></code></pre>
<ul>
<li>命名coverpoint和bin</li>
</ul>
<pre class="hljs"><code><div>  <span class="hljs-keyword">coverpoint</span> CovKind;
    <span class="hljs-keyword">coverpoint</span> tr<span class="hljs-variable">.kind</span> {
      <span class="hljs-keyword">bins</span> zero = {<span class="hljs-number">0</span>}; <span class="hljs-comment">//1个bin代表kind == 0</span>
      <span class="hljs-keyword">bins</span> lo = {[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>], <span class="hljs-number">5</span>}; <span class="hljs-comment">//1个bin代表1:3和5</span>
      <span class="hljs-keyword">bins</span> hi[] = {[<span class="hljs-number">8</span>:$]}; <span class="hljs-comment">//8个独立的bin代表8:15</span>
      <span class="hljs-keyword">bins</span> misc = <span class="hljs-keyword">default</span>; <span class="hljs-comment">//1个bin代表剩余所有值</span>
    }
  <span class="hljs-keyword">endgroup</span>
</div></code></pre>
<ul>
<li>条件覆盖率
<ul>
<li>可以使用 <code>iff</code> 给coverpoint添加条件，常用于在复位期间关闭覆盖以忽略不合理的条件触发</li>
<li>也可以使用start和stop函数来控制covergroup各个独立实例</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">covergroup</span> CoverPort;
  <span class="hljs-keyword">coverpoint</span> port <span class="hljs-keyword">iff</span> (!bus_if<span class="hljs-variable">.reset</span>);
<span class="hljs-keyword">endgroup</span>

<span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span>
  CovPort ck = <span class="hljs-keyword">new</span>();
  #<span class="hljs-number">1</span>ns;
  ck<span class="hljs-variable">.stop</span>();
  bus_if<span class="hljs-variable">.reset</span> = <span class="hljs-number">1</span>;
  #<span class="hljs-number">100</span>ns bus_if<span class="hljs-variable">.reset</span> = <span class="hljs-number">0</span>;
  ck<span class="hljs-variable">.start</span>();
  ...
<span class="hljs-keyword">end</span>
</div></code></pre>
<ul>
<li>翻转覆盖率
<ul>
<li>可以记录变量从A值到B值的跳转情况，也可以确定任何长度的翻转次数</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">covergroup</span> CoverPort;
  <span class="hljs-keyword">coverpoint</span> port {
    <span class="hljs-keyword">bins</span> t1 = (<span class="hljs-number">0</span>=&gt;<span class="hljs-number">1</span>), (<span class="hljs-number">0</span>=&gt;<span class="hljs-number">2</span>), (<span class="hljs-number">0</span>=&gt;<span class="hljs-number">3</span>);
  }
<span class="hljs-keyword">endgroup</span>
</div></code></pre>
<ul>
<li>wildcard覆盖率
<ul>
<li>可以使用wildcard创建多个状态或者翻转</li>
<li>在表达式中，任何x，z或者?都会被当成0或1的通配符</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">bit</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] port;
<span class="hljs-keyword">covergroup</span> CoverPort;
  <span class="hljs-keyword">coverpoint</span> port {
    <span class="hljs-keyword">wildcard</span> <span class="hljs-keyword">bins</span> even = {<span class="hljs-number">3</span>'b??<span class="hljs-number">0</span>};
    <span class="hljs-keyword">wildcard</span> <span class="hljs-keyword">bins</span> odd = {<span class="hljs-number">3</span>'b??<span class="hljs-number">1</span>};
  }
<span class="hljs-keyword">endgroup</span>
</div></code></pre>
<ul>
<li>忽略的bin
<ul>
<li>对于不计算功能的域值可以使用 <code>ignore_bins</code> 来排除</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">bit</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] low_ports_0_5;
<span class="hljs-keyword">covergroup</span> CoverPort;
  <span class="hljs-keyword">coverpoint</span> low_ports_0_5 {
    <span class="hljs-keyword">ignore_bins</span> hi = {[<span class="hljs-number">6</span>, <span class="hljs-number">7</span>]};
  }
<span class="hljs-keyword">endgroup</span>
</div></code></pre>
<ul>
<li>非法的bin
<ul>
<li>可以使用 <code>illegal_bins</code> 对非法的bin进行标识</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">bit</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] low_ports_0_5;
<span class="hljs-keyword">covergroup</span> CoverPort;
  <span class="hljs-keyword">coverpoint</span> low_ports_0_5 {
    <span class="hljs-keyword">illegal_bins</span> hi = {[<span class="hljs-number">6</span>, <span class="hljs-number">7</span>]};
  }
<span class="hljs-keyword">endgroup</span>
</div></code></pre>
<ul>
<li>交叉覆盖率
<ul>
<li>coverpoint是记录单个变量或者表达式的观测值，多个变量之间值的组合情况，需要使用交叉覆盖率（cross），cross语句只允许带coverpoint或者简单的变量名</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">class</span> Transaction;
  <span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] kind;
  <span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span> [<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] port;
<span class="hljs-keyword">endclass</span>

Transaction tr;

<span class="hljs-keyword">covergroup</span> CovPort;
  kind: <span class="hljs-keyword">coverpoint</span> tr<span class="hljs-variable">.kind</span>;
  port: <span class="hljs-keyword">coverpoint</span> tr<span class="hljs-variable">.port</span>;
  <span class="hljs-keyword">cross</span> kind, port;
<span class="hljs-keyword">endgroup</span>
</div></code></pre>
<ul>
<li>排除部分cross bin
<ul>
<li>使用 <code>ignore_bins</code>, <code>binsof</code>, <code>intersect</code> 分别指定coverpoint和值域，可以清除很多不关心的crossbin</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">covergroup</span> CovPort;
  port: <span class="hljs-keyword">coverpoint</span> tr<span class="hljs-variable">.port</span> {
    <span class="hljs-keyword">bins</span> port[] = {[<span class="hljs-number">0</span>:$]};
  }
  kind: <span class="hljs-keyword">coverpoint</span> tr<span class="hljs-variable">.kind</span> {
    <span class="hljs-keyword">bins</span> zero = {<span class="hljs-number">0</span>};
    <span class="hljs-keyword">bins</span> lo = {[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>]};        
    <span class="hljs-keyword">bins</span> hi[] = {[<span class="hljs-number">8</span>:$]};
    <span class="hljs-keyword">bins</span> misc = <span class="hljs-keyword">default</span>;
  }

  <span class="hljs-keyword">cross</span> kind, port {
    <span class="hljs-keyword">ignore_bins</span> hi = <span class="hljs-keyword">binsof</span>(port) <span class="hljs-keyword">intersect</span> {<span class="hljs-number">7</span>};
    <span class="hljs-keyword">ignore_bins</span> md = <span class="hljs-keyword">binsof</span>(port) <span class="hljs-keyword">intersect</span> {<span class="hljs-number">0</span>} &amp;&amp; <span class="hljs-keyword">binsof</span>(kind) <span class="hljs-keyword">intersect</span> {[<span class="hljs-number">9</span>:<span class="hljs-number">11</span>]};
    <span class="hljs-keyword">ignore_bins</span> lo = <span class="hljs-keyword">binsof</span>(kind<span class="hljs-variable">.lo</span>);
  }
<span class="hljs-keyword">endgroup</span>
</div></code></pre>
<ul>
<li>精细的交叉覆盖率指定
<ul>
<li>更适合的方式是不使用自动分配的cross bin，而自己声明感兴趣的cross bin</li>
<li>假如有两个随机变量a和b，它们带着三种感兴趣的状态{a==0, b==0}, {a==1, b==0} 和 {b==1}</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">class</span> Transaction
  <span class="hljs-keyword">rand</span> <span class="hljs-keyword">bit</span> a, b;
<span class="hljs-keyword">endclass</span>

<span class="hljs-keyword">covergroup</span> CrossBinNames;
  a: <span class="hljs-keyword">coverpoint</span> tr<span class="hljs-variable">.a</span> {
    <span class="hljs-keyword">bins</span> a0 = {<span class="hljs-number">0</span>};
    <span class="hljs-keyword">bins</span> a1 = {<span class="hljs-number">1</span>};
    option<span class="hljs-variable">.weight</span> = <span class="hljs-number">0</span>; <span class="hljs-comment">//不计算覆盖率</span>
  }
  b: <span class="hljs-keyword">coverpoint</span> tr<span class="hljs-variable">.b</span> {
    <span class="hljs-keyword">bins</span> b0 = {<span class="hljs-number">0</span>};
    <span class="hljs-keyword">bins</span> b1 = {<span class="hljs-number">1</span>};
    oprion<span class="hljs-variable">.weight</span> = <span class="hljs-number">0</span>; <span class="hljs-comment">//不计算覆盖率</span>
  }
  ab: <span class="hljs-keyword">cross</span> a, b {
    <span class="hljs-keyword">bins</span> a0b0 = <span class="hljs-keyword">binsof</span>(a<span class="hljs-variable">.a0</span>) &amp;&amp; <span class="hljs-keyword">binsof</span>(b<span class="hljs-variable">.b0</span>);
    <span class="hljs-keyword">bins</span> a1b0 = <span class="hljs-keyword">binsof</span>(a<span class="hljs-variable">.a1</span>) &amp;&amp; <span class="hljs-keyword">binsof</span>(b<span class="hljs-variable">.b0</span>);
    <span class="hljs-keyword">bins</span> b1 = <span class="hljs-keyword">binsof</span>(b<span class="hljs-variable">.b1</span>);
  }
<span class="hljs-keyword">endgroup</span>

<span class="hljs-keyword">covergroup</span> CrossBinsofIntersect;
  a: <span class="hljs-keyword">coverpoint</span> tr<span class="hljs-variable">.a</span> {
    option<span class="hljs-variable">.weight</span> = <span class="hljs-number">0</span>;
  }
  b: <span class="hljs-keyword">coverpoint</span> tr<span class="hljs-variable">.b</span> {
    options<span class="hljs-variable">.weight</span> = <span class="hljs-number">0</span>;
  }
  ab: <span class="hljs-keyword">cross</span> a, b {
    <span class="hljs-keyword">bins</span> a0b0 = <span class="hljs-keyword">binsof</span>(a) <span class="hljs-keyword">intersect</span> {<span class="hljs-number">0</span>} &amp;&amp; <span class="hljs-keyword">binsof</span>(b) <span class="hljs-keyword">intersect</span> {<span class="hljs-number">0</span>};
    <span class="hljs-keyword">bins</span> a1b0 = <span class="hljs-keyword">binsof</span>(a) <span class="hljs-keyword">intersect</span> {<span class="hljs-number">1</span>} &amp;&amp; <span class="hljs-keyword">binsof</span>(b) <span class="hljs-keyword">intersect</span> {<span class="hljs-number">0</span>};
  }
<span class="hljs-keyword">endgroup</span>
</div></code></pre>
<ul>
<li>覆盖选项
<ul>
<li>如果一个covergroup被例化多次，默认情况下会将所有实例的覆盖率合并到一起，如果需要单独列出每个covergroup实例的覆盖率，需要设置覆盖选项per_instance</li>
<li>可以通过参数对每一个实例传入单独的注释</li>
<li>默认情况下，数值采样1次就可以计入有效的bin，可以通过修改at_least来修改每个bin的数值最少的采样次数，如果低于at_least数值，则不会被记入bin中</li>
<li>可以使用option.goal设置覆盖目标</li>
<li>sample(); 采样</li>
<li>get_coverage()/get_inst_coverage(); 获取覆盖率，返回0-100的real数值</li>
<li>set_inst_name(string); 设置covergroup的名称</li>
<li>start()/stop()；使能或者关闭覆盖率的收集</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div>  <span class="hljs-comment">// per_instance</span>
  <span class="hljs-keyword">covergroup</span> CoverLength;
    <span class="hljs-keyword">coverpoint</span> tr<span class="hljs-variable">.length</span>;
    option<span class="hljs-variable">.per_instance</span> = <span class="hljs-number">1</span>;
  <span class="hljs-keyword">endgroup</span>

  <span class="hljs-comment">//comment</span>
  <span class="hljs-keyword">covergroup</span> CoverPort(<span class="hljs-keyword">int</span> lo, hi, <span class="hljs-keyword">string</span> comment);
    option<span class="hljs-variable">.comment</span> = comment
    <span class="hljs-keyword">coverpoint</span> port {
      <span class="hljs-keyword">bins</span> range = {[lo:hi]};
    }
  <span class="hljs-keyword">endgroup</span>

  CoverPort cp_lo = <span class="hljs-keyword">new</span>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-string">"Low port numbers"</span>);

  <span class="hljs-comment">//goal</span>
  <span class="hljs-keyword">covergroup</span> CoverPort;
    <span class="hljs-keyword">coverpoint</span> port;
    option<span class="hljs-variable">.goal</span> = <span class="hljs-number">90</span>;
  <span class="hljs-keyword">endgroup</span>
</div></code></pre>
<ul>
<li>数据分析
<ul>
<li>使用 <code>$get_coverage()</code> 可以得到总体的覆盖率</li>
<li>使用 <code>covergroup_inst.get_inst_coverage()</code> 获取单个covergroup实例的覆盖率</li>
<li>可以使用这些函数在一个测试中检测覆盖率的变化</li>
<li>如果覆盖率水平在一段时间之后没有提高，那么这个测试就应该停止</li>
<li>重启新的随机种子或者测试可能有望提高覆盖率</li>
<li>测试可以基于功能覆盖率重新限定随机的约束，但是这种测试很难编写</li>
</ul>
</li>
</ul>
<h1 id="1120">11.20</h1>
<h2 id="%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">类型转换</h2>
<ul>
<li>概述
<ul>
<li>静态转换：在转换表达式前加上单引号，不会对转换值做检查</li>
<li>动态转换：使用系统函数 <code>$cast(tgt, src)</code></li>
<li>静态转换和动态转换均需要操作符号或者系统函数，被称为显示转换</li>
<li>不需要进行转换的操作称之为隐式转换，例如赋值语句左右侧位宽不一样，会先做位宽扩展或截取再做赋值</li>
</ul>
</li>
<li>动态转换
<ul>
<li>使用类的时候，类句柄的向下转换（从父类句柄转换为子类句柄）时，需要使用 <code>$cast()</code></li>
<li>如果子类句柄赋值给父类句柄时，赋值是合法的。但分别利用子类句柄和父类句柄调用相同对象的成员时，可能会有不同的表现。</li>
<li><code>$cast(tgt, src)</code> 会检查句柄所指向的对象类型，而不仅仅检查句柄本身，一旦源对象跟目的句柄是同一类型，或者是目的句柄的扩展类，函数执行成功返回1，否则返回0</li>
<li><em><strong>父类句柄可以指向父类对象和子类对象，子类句柄只可以指向子类对象</strong></em></li>
</ul>
</li>
</ul>
<h2 id="%E8%99%9A%E6%96%B9%E6%B3%95">虚方法</h2>
<ul>
<li>由于类的多态性，通过虚方法，无需关注句柄指向的对象类型是父类还是子类，就可以实现动态绑定(动态方法查找)。</li>
<li>动态绑定是指在调用方法时，会在运行时来确定句柄指向对象的类型，再动态指向应该调用的方法，通过虚方法的使用来实现类成员方法调用时的动态查找。</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">class</span> basic_test;
...
  <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">task</span> test();
  ...
  <span class="hljs-keyword">endtask</span>
...
<span class="hljs-keyword">endclass</span>
</div></code></pre>
<ul>
<li>为父类定义方法时，如果该方法日后可能会被覆盖或者继承，应该声明为虚方法。虚方法尽量定义在底层父类中，并且只需要声明一次即可，定义在中间层对底层会不起作用。</li>
<li>虚方法的继承也需要遵循相同的参数和返回类型，否则子类定义的方法须归为同名不同参的其他方法</li>
<li>注意不能通过虚方法动态查找到子类成员，没有任何方法可以从父类句柄索引到子类对象的成员</li>
</ul>

</body>
</html>
